load("C:/UCLA/thesis_ideas/PhD_thesis/one_to_one_verification/.RData")
1+8
matrix(c(1,2,3,4,5,6,7,8,9),nrow=3) %*% t(matrix(c(1,2,3,4,5,6,7,8,9),nrow=3))
matrix(c(1,2,3,4,5,6),nrow=2) %*% t(matrix(c(1,2,3,4,5,6),nrow=2))
install.packages("plotly")
library(plotly)
library(plotly)
trace_0 <- rnorm(100, mean = 5)
trace_1 <- rnorm(100, mean = 0)
trace_2 <- rnorm(100, mean = -5)
x <- c(1:100)
data <- data.frame(x, trace_0, trace_1, trace_2)
p <- plot_ly(data, x = ~x) %>%
add_trace(y = ~trace_0, name = 'trace 0',mode = 'lines') %>%
add_trace(y = ~trace_1, name = 'trace 1', mode = 'lines+markers') %>%
add_trace(y = ~trace_2, name = 'trace 2', mode = 'markers')
print(p)
getOption("repos")
options(repos = c(CRAN = "https://cran.rstudio.com"))
install.packages("stringi")
install.packages("stringi")
install.packages("installr");
require(installr)
updateR()
install.packages("installr");
install.packages("installr",lib='C:/Users/Daisy/Documents/R/win-library/3.5');
formula = choice ~ pf + cl + loc + wk + tod + seas | 0 | 0 | 0 | 1
MUtils = matrix(c(0.3,0.2,0.1,0.2,0.3,0.1), ncol=2)
WUtils = matrix(c(0.3,0.2,0.3,0.2,0.3,0.2), ncol=3)
studentUtils = WUtils
collegeUtils = MUtils
slots = c(1,2)
studentOptimal = FALSE
args = galeShapley.validate(collegeUtils, studentUtils, collegePref, studentPref)
library(matchingR)
args = galeShapley.validate(collegeUtils, studentUtils, collegePref, studentPref)
args = galeShapley.validate(collegeUtils, studentUtils, NULL, NULL)
args$proposerUtils
args$reviewerUtils
number_of_students = NROW(args$proposerUtils)
# number of colleges
number_of_colleges = NCOL(args$proposerUtils)
number_of_students
if(length(slots)==1) {
slots = rep(slots, number_of_colleges)
}
proposerUtils = repcol(args$proposerUtils, slots)
reviewerUtils = reprow(args$reviewerUtils, slots)
repcol = function(x, n){
s = NCOL(x)
if(length(n) == 1) {
return(matrix(x[,rep(1:s, each = n)], nrow = NROW(x), ncol = s*n))
}
matrix(x[,rep(1:s, n)], nrow = NROW(x), ncol = sum(n))
}
#' Repeat each row of a matrix n times
#'
#' This function repeats each row of a matrix n times
#'
#' @param x is the input matrix
#' @param n is the number of repetitions (can be a vector)
#' @return matrix with repeated rows
reprow = function(x, n){
s = NROW(x)
if(length(n) == 1) {
return(matrix(x[rep(1:s, each = n),], nrow = s*n, ncol = NCOL(x)))
}
matrix(x[rep(1:s, n),], nrow = sum(n), ncol = NCOL(x))
}
proposerUtils = repcol(args$proposerUtils, slots)
reviewerUtils = reprow(args$reviewerUtils, slots)
proposerUtils
reviewerUtils
proposerPref = sortIndex(as.matrix(proposerUtils));
proposerPref
res = cpp_wrapper_galeshapley(as.matrix(proposerPref), as.matrix(reviewerUtils))
str(res)
# number of slots
M = length(res$proposals)
# number of students
N = length(res$engagements)
res = c(res, list(
"unmatched.colleges" = rep(NA, length = sum(res$proposals == N)),
"unmatched.students" = seq(from = 0, to = N - 1)[res$engagements == M] + 1
))
unmatched.colleges = seq(from = 0, to = M - 1)[res$proposals == N] + 1
# assemble results
res$matched.colleges = list()
# map proposals back into slots
cumsum.slotsLower = cumsum(c(0, slots[-length(slots)]))+1
cumsum.slotsUpper = cumsum(slots)
for(jX in 1:number_of_colleges) {
# fill slots with student ids
res$matched.colleges[[jX]] = res$proposals[cumsum.slotsLower[jX]:cumsum.slotsUpper[jX]] + 1
# set vacant slots to NA
res$matched.colleges[[jX]][res$matched.colleges[[jX]] == (number_of_students + 1)] = NA
# unmatched colleges
res$unmatched.colleges[unmatched.colleges %in% (cumsum.slotsLower[jX]:cumsum.slotsUpper[jX])] = jX
}
str(res)
res$matched.students = matrix(NA, nrow = number_of_students, ncol=1)
for(jX in 1:number_of_colleges) {
res$matched.students[res$matched.colleges[[jX]]] = jX
}
str(res)
res$engagements = NULL
res$proposals = NULL
str(res)
galeShapley.checkStability = function(collegeUtils, studentUtils, res$proposals, res$engagements)
galeShapley.checkStability(collegeUtils, studentUtils, res$proposals, res$engagements)
results.collegeoptimal = galeShapley.collegeAdmissions(studentUtils = WUtils,
collegeUtils = MUtils,
slots = c(1,2),
studentOptimal = FALSE)
str(results.collegeoptimal)
galeShapley.checkStability(MUtils, WUtils, results.collegeoptimal$proposals, results.collegeoptimal$engagements)
ss=seq(0,1,by=0.01)
plot(ss,-ss^2)
plot(ss,ss^2)
plot(ss,ss^4)
plot(ss,ss^4-ss^2)
plot(ss,ss^2-ss^4)
plot(ss,ss^2+ss^4)
plot(ss,-ss^4)
plot(ss,ss*ss^2)
plot(ss,ss)
plot(ss,ss^2)
plot(ss,ss^2-ss)
plot(ss,ss^2+ss)
plot(ss,ss^(3/2)/ss)
load("C:\\UCLA\\thesis_ideas\\PhD_thesis\\latent_class_model\\LC_two_sided_sim_EM\\t_3_adj_llik_eq_marg_1_combined_eq_const\\Resultst_3_N_1000_wm_0.5_0.5_1.0_1.0_0.5_0.5")
load("C:\\UCLA\\thesis_ideas\\PhD_thesis\\latent_class_model\\LC_two_sided_sim_EM\\t_3_adj_llik_eq_marg_1_combined_eq_const\\Resultst_3_N_1000_wm_0.5_0.5_1.0_1.0_0.5_0.5.RData")
View(data_w)
View(X_m)
load("C:\\UCLA\\thesis_ideas\\PhD_thesis\\latent_class_model\\LC_two_sided_sim_EM\\Results_B200_N200_Q2_all_0.5_0.5_1.0.RData")
print("W: median:")
print(apply(params_all_w[,1:(num_beta*Q)], 2, median, na.rm=T))
print("W: mean:")
print(apply(params_all_w[,1:(num_beta*Q)], 2, mean, na.rm=T))
print("W: SD:")
print(apply(params_all_w[,1:(num_beta*Q)], 2, sd, na.rm=T))
print("M: median:")
print(apply(params_all_m[,1:(num_beta*Q)], 2, median, na.rm=T))
print("M: mean:")
print(apply(params_all_m[,1:(num_beta*Q)], 2, mean, na.rm=T))
print("M: SD:")
print(apply(params_all_m[,1:(num_beta*Q)], 2, sd, na.rm=T))
library(doParallel)
install.packages("doParallel")
detectCores()
library(doParallel)
detectCores()
load("C:\\UCLA\\thesis_ideas\\PhD_thesis\\latent_class_model\\generate_matching_data\\matchings_N_20_50_100_200_500_1000_2000_B200_choices_5.RData")
x=seq(0.00001, 0.2,by=0.00001)
plot(x,log(x))
plot(x,log(1-x))
plot(1-x,log(1-x))
plot(1+x,log(1+x))
plot(c(1-x,1,1+x))
c=seq(0.8,1.2,by=0.00001)
rm(c)
x=seq(0.8,1.2,by=0.00001)
plot(x)
plot(x,log(x))
log(0.8/1)
log(0.8)
log(0.9)
load("C:\\UCLA\\thesis_ideas\\PhD_thesis\\latent_class_model\\misspecified_many_cleaned_up_works_gw_gm_individuals_BLP_simplified_eqconst\\result_N_20_50_100_200_500_1000_2000_B200_choices_6.RData")
print(paste0("n=", n, ": nonconvergence ", sum(noconv), " of ", B))
# print("beta_sim:")
# print(beta_sim)
print(paste0("choices = ", choices))
print(paste0("mean(w_ave_choices) = ", mean(w_ave_choices, na.rm = T)))
print(paste0("mean(m_ave_choices) = ", mean(m_ave_choices, na.rm = T)))
print("beta_med:")
print(beta_med)
print("beta_iqr:")
print(beta_iqr)
print("beta_mean:")
print(beta_mean)
print("beta_sd:")
print(beta_sd)
print("Gamma_med:")
print(Gamma_med)
print(" ")
print("Ajusted betas:")
print("beta_med_adj:")
print(beta_med_adj)
print("beta_iqr_adj:")
print(beta_iqr_adj)
print("beta_mean_adj:")
print(beta_mean_adj)
print("beta_sd_adj:")
print(beta_sd_adj)
load("C:\\UCLA\\thesis_ideas\\PhD_thesis\\latent_class_model\\misspecified_many_cleaned_up_works_gw_gm_individuals_BLP_simplified_eqconst\\result_N_20_50_100_200_500_1000_2000_B200_choices_3.RData")
print(paste0("n=", n, ": nonconvergence ", sum(noconv), " of ", B))
# print("beta_sim:")
# print(beta_sim)
print(paste0("choices = ", choices))
print(paste0("mean(w_ave_choices) = ", mean(w_ave_choices, na.rm = T)))
print(paste0("mean(m_ave_choices) = ", mean(m_ave_choices, na.rm = T)))
print("beta_med:")
print(beta_med)
print("beta_iqr:")
print(beta_iqr)
print("beta_mean:")
print(beta_mean)
print("beta_sd:")
print(beta_sd)
print("Gamma_med:")
print(Gamma_med)
print(" ")
print("Ajusted betas:")
print("beta_med_adj:")
print(beta_med_adj)
print("beta_iqr_adj:")
print(beta_iqr_adj)
print("beta_mean_adj:")
print(beta_mean_adj)
print("beta_sd_adj:")
print(beta_sd_adj)
load("C:\\UCLA\\thesis_ideas\\PhD_thesis\\latent_class_model\\misspecified_many_cleaned_up_works_gw_gm_individuals_BLP_simplified_eqconst\\result_N_20_50_100_200_500_1000_2000_B200_choices_3_sum_top.RData")
print(paste0("n=", n, ": nonconvergence ", sum(noconv), " of ", B))
# print("beta_sim:")
# print(beta_sim)
print(paste0("choices = ", choices))
print(paste0("mean(w_ave_choices) = ", mean(w_ave_choices, na.rm = T)))
print(paste0("mean(m_ave_choices) = ", mean(m_ave_choices, na.rm = T)))
print("beta_med:")
print(beta_med)
print("beta_iqr:")
print(beta_iqr)
print("beta_mean:")
print(beta_mean)
print("beta_sd:")
print(beta_sd)
print("Gamma_med:")
print(Gamma_med)
print(" ")
print("Ajusted betas:")
print("beta_med_adj:")
print(beta_med_adj)
print("beta_iqr_adj:")
print(beta_iqr_adj)
print("beta_mean_adj:")
print(beta_mean_adj)
print("beta_sd_adj:")
print(beta_sd_adj)
setwd("C:\\UCLA\\research_projects\\many_to_many_dissertation")
source("unpartnered_partnered_3.R")
source("unpartnered_partnered_3.R")
print("Standard error:")
print(sqrt(out$covar))
print("Standard error (centered:")
print(sqrt(out$covar2))
dff = data.frame(out$solution)
kable(dff)
pmfj = check_CP_latent(ff, out$solution, mu, Xdata, Zdata, symmetric, max_choices)
print("estimated joint probabilities")
print(pmfj$pmfj_est)
print("observed joint probabilities")
print(pmfj$pmfj_obs)
log.txt <- tic.log(format = TRUE)
log.lst <- tic.log(format = FALSE)
tic.clearlog()
timings <- unlist(lapply(log.lst, function(x) x$toc - x$tic))
writeLines(unlist(log.txt))
sum(pmfj$pmfj_est[1:4,1:4])
sum(pmfj$pmfj_obs[1:4,1:4])
library(ggplot2)
# plot by education
joint_edu_df = data.frame(self_type = processed_data$Xdata[,"educlevel_t"], spouse_type = processed_data$Zdata[,"educlevel_t"])
# joint_edu_df = joint_edu_df[rep(row.names(joint_edu_df), processed_data$females[,"paired"]),]
joint_edu_df$self_type = as.factor(joint_edu_df$self_type)
# joint_edu_df$spouse_type = as.factor(joint_edu_df$spouse_type)
ggplot(joint_edu_df, aes(x=spouse_type, fill=self_type)) +  geom_histogram(binwidth=1, alpha=.5, position="dodge") +
scale_x_discrete(name ="Spouse Education", limits=c("<HS","HS","SomeCollege","BA+")) +
ggtitle("Education Homophily") + scale_fill_discrete(name="Self Education",
#breaks=c("1", "2", "3", "4"),
labels=c("<HS","HS","SomeCollege","BA+"))
# plot by age group
joint_age_df = data.frame(self_type = processed_data$Xdata[,"tage_t"], spouse_type = processed_data$Zdata[,"tage_t"])
# joint_age_df = joint_age_df[rep(row.names(joint_age_df), processed_data$females[,"paired"]),]
joint_age_df$self_type = as.factor(joint_age_df$self_type)
# joint_age_df$spouse_type = as.factor(joint_age_df$spouse_type)
ggplot(joint_age_df, aes(x=spouse_type, fill=self_type)) +  geom_histogram(binwidth=1, alpha=.5, position="dodge") +
scale_x_discrete(name ="Spouse Age Group", limits=age_label) +
ggtitle("Age Homophily") + scale_fill_discrete(name="Self Age",
#breaks=c("1", "2", "3", "4"),
labels=age_label)
# plot by race
joint_race_df = data.frame(self_type = processed_data$Xdata[,"race_t"], spouse_type = processed_data$Zdata[,"race_t"])
# joint_race_df = joint_race_df[rep(row.names(joint_race_df), processed_data$females[,"paired"]),]
joint_race_df$self_type = as.factor(joint_race_df$self_type)
# joint_race_df$spouse_type = as.factor(joint_race_df$spouse_type)
ggplot(joint_race_df, aes(x=spouse_type, fill=self_type)) +  geom_histogram(binwidth=1, alpha=.5, position="dodge") +
scale_x_discrete(name ="Spouse Race", limits=race_label) +
ggtitle("Race Homophily") + scale_fill_discrete(name="Self Race",
#breaks=c("1", "2", "3", "4"),
labels=race_label)
source("unpartnered_partnered_3.R")
source("unpartnered_partnered_3.R")
source("unpartnered_partnered_3.R")
kable(dff)
print(kable(dff))
source("unpartnered_partnered_3.R")
load("C:\\UCLA\\thesis_ideas\\PhD_thesis\\many_to_many_application\\processed_data_sub_age_homophily_greater_smaller.Rdata")
